//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/ConcurrentHashMap.java
//

#ifndef _JavaUtilConcurrentConcurrentHashMap_H_
#define _JavaUtilConcurrentConcurrentHashMap_H_

#include "J2ObjC_header.h"
#include "java/io/Serializable.h"
#include "java/util/AbstractCollection.h"
#include "java/util/AbstractMap.h"
#include "java/util/AbstractSet.h"
#include "java/util/Enumeration.h"
#include "java/util/Iterator.h"
#include "java/util/concurrent/ConcurrentMap.h"
#include "java/util/concurrent/locks/ReentrantLock.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_HashEntry;
@class JavaUtilConcurrentConcurrentHashMap_Segment;
@class SunMiscUnsafe;
@protocol JavaUtilCollection;
@protocol JavaUtilMap;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilSet;

#define JavaUtilConcurrentConcurrentHashMap_DEFAULT_INITIAL_CAPACITY 16
#define JavaUtilConcurrentConcurrentHashMap_DEFAULT_LOAD_FACTOR 0.75f
#define JavaUtilConcurrentConcurrentHashMap_DEFAULT_CONCURRENCY_LEVEL 16
#define JavaUtilConcurrentConcurrentHashMap_MAXIMUM_CAPACITY 1073741824
#define JavaUtilConcurrentConcurrentHashMap_MIN_SEGMENT_TABLE_CAPACITY 2
#define JavaUtilConcurrentConcurrentHashMap_MAX_SEGMENTS 65536
#define JavaUtilConcurrentConcurrentHashMap_RETRIES_BEFORE_LOCK 2

@interface JavaUtilConcurrentConcurrentHashMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentMap, JavaIoSerializable > {
 @public
  jint segmentMask_;
  jint segmentShift_;
  IOSObjectArray *segments_;
  id<JavaUtilSet> keySet_ConcurrentHashMap_;
  id<JavaUtilSet> entrySet__;
  id<JavaUtilCollection> values__;
}

#pragma mark Public

- (instancetype)init;

- (instancetype)initWithInt:(jint)initialCapacity;

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor;

- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                    withInt:(jint)concurrencyLevel;

- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)m;

- (void)clear;

- (jboolean)containsWithId:(id)value;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilEnumeration>)elements;

- (id<JavaUtilSet>)entrySet;

- (id)getWithId:(id)key;

- (jboolean)isEmpty;

- (id<JavaUtilEnumeration>)keys;

- (id<JavaUtilSet>)keySet;

- (id)putWithId:(id)key
         withId:(id)value;

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)m;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (jint)size;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

+ (JavaUtilConcurrentConcurrentHashMap_HashEntry *)entryAtWithJavaUtilConcurrentConcurrentHashMap_HashEntryArray:(IOSObjectArray *)tab
                                                                                                         withInt:(jint)i;

+ (JavaUtilConcurrentConcurrentHashMap_HashEntry *)entryForHashWithJavaUtilConcurrentConcurrentHashMap_Segment:(JavaUtilConcurrentConcurrentHashMap_Segment *)seg
                                                                                                       withInt:(jint)h;

+ (JavaUtilConcurrentConcurrentHashMap_Segment *)segmentAtWithJavaUtilConcurrentConcurrentHashMap_SegmentArray:(IOSObjectArray *)ss
                                                                                                       withInt:(jint)j;

+ (void)setEntryAtWithJavaUtilConcurrentConcurrentHashMap_HashEntryArray:(IOSObjectArray *)tab
                                                                 withInt:(jint)i
                       withJavaUtilConcurrentConcurrentHashMap_HashEntry:(JavaUtilConcurrentConcurrentHashMap_HashEntry *)e;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, segments_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, keySet_ConcurrentHashMap_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, entrySet__, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, values__, id<JavaUtilCollection>)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, DEFAULT_INITIAL_CAPACITY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, DEFAULT_LOAD_FACTOR, jfloat)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, DEFAULT_CONCURRENCY_LEVEL, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, MAXIMUM_CAPACITY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, MIN_SEGMENT_TABLE_CAPACITY, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, MAX_SEGMENTS, jint)

J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap, RETRIES_BEFORE_LOCK, jint)

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_HashEntry *JavaUtilConcurrentConcurrentHashMap_entryAtWithJavaUtilConcurrentConcurrentHashMap_HashEntryArray_withInt_(IOSObjectArray *tab, jint i);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_setEntryAtWithJavaUtilConcurrentConcurrentHashMap_HashEntryArray_withInt_withJavaUtilConcurrentConcurrentHashMap_HashEntry_(IOSObjectArray *tab, jint i, JavaUtilConcurrentConcurrentHashMap_HashEntry *e);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Segment *JavaUtilConcurrentConcurrentHashMap_segmentAtWithJavaUtilConcurrentConcurrentHashMap_SegmentArray_withInt_(IOSObjectArray *ss, jint j);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_HashEntry *JavaUtilConcurrentConcurrentHashMap_entryForHashWithJavaUtilConcurrentConcurrentHashMap_Segment_withInt_(JavaUtilConcurrentConcurrentHashMap_Segment *seg, jint h);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor, jint concurrencyLevel);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(jint initialCapacity, jfloat loadFactor, jint concurrencyLevel) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_init(JavaUtilConcurrentConcurrentHashMap *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(JavaUtilConcurrentConcurrentHashMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap)

@interface JavaUtilConcurrentConcurrentHashMap_HashEntry : NSObject {
 @public
  jint hash__;
  id key_;
  id value_;
  JavaUtilConcurrentConcurrentHashMap_HashEntry *next_;
}

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)hash_
                     withId:(id)key
                     withId:(id)value
withJavaUtilConcurrentConcurrentHashMap_HashEntry:(JavaUtilConcurrentConcurrentHashMap_HashEntry *)next;

- (void)setNextWithJavaUtilConcurrentConcurrentHashMap_HashEntry:(JavaUtilConcurrentConcurrentHashMap_HashEntry *)n;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_HashEntry)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashEntry, key_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashEntry, value_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashEntry, next_, JavaUtilConcurrentConcurrentHashMap_HashEntry *)

FOUNDATION_EXPORT SunMiscUnsafe *JavaUtilConcurrentConcurrentHashMap_HashEntry_UNSAFE_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap_HashEntry, UNSAFE_, SunMiscUnsafe *)

FOUNDATION_EXPORT jlong JavaUtilConcurrentConcurrentHashMap_HashEntry_nextOffset_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap_HashEntry, nextOffset_, jlong)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_HashEntry_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_HashEntry_(JavaUtilConcurrentConcurrentHashMap_HashEntry *self, jint hash_, id key, id value, JavaUtilConcurrentConcurrentHashMap_HashEntry *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_HashEntry *new_JavaUtilConcurrentConcurrentHashMap_HashEntry_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_HashEntry_(jint hash_, id key, id value, JavaUtilConcurrentConcurrentHashMap_HashEntry *next) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_HashEntry)

@interface JavaUtilConcurrentConcurrentHashMap_Segment : JavaUtilConcurrentLocksReentrantLock < JavaIoSerializable > {
 @public
  IOSObjectArray *table_;
  jint count_;
  jint modCount_;
  jint threshold_;
  jfloat loadFactor_;
}

#pragma mark Package-Private

- (instancetype)initWithFloat:(jfloat)lf
                      withInt:(jint)threshold
withJavaUtilConcurrentConcurrentHashMap_HashEntryArray:(IOSObjectArray *)tab;

- (void)clear;

- (id)putWithId:(id)key
        withInt:(jint)hash_
         withId:(id)value
    withBoolean:(jboolean)onlyIfAbsent;

- (id)removeWithId:(id)key
           withInt:(jint)hash_
            withId:(id)value;

- (id)replaceWithId:(id)key
            withInt:(jint)hash_
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                  withInt:(jint)hash_
                   withId:(id)oldValue
                   withId:(id)newValue;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Segment)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Segment, table_, IOSObjectArray *)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_Segment_MAX_SCAN_RETRIES_;
J2OBJC_STATIC_FIELD_GETTER(JavaUtilConcurrentConcurrentHashMap_Segment, MAX_SCAN_RETRIES_, jint)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_withInt_withJavaUtilConcurrentConcurrentHashMap_HashEntryArray_(JavaUtilConcurrentConcurrentHashMap_Segment *self, jfloat lf, jint threshold, IOSObjectArray *tab);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Segment *new_JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_withInt_withJavaUtilConcurrentConcurrentHashMap_HashEntryArray_(jfloat lf, jint threshold, IOSObjectArray *tab) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Segment)

@interface JavaUtilConcurrentConcurrentHashMap_HashIterator : NSObject {
 @public
  jint nextSegmentIndex_;
  jint nextTableIndex_;
  IOSObjectArray *currentTable_;
  JavaUtilConcurrentConcurrentHashMap_HashEntry *nextEntry__;
  JavaUtilConcurrentConcurrentHashMap_HashEntry *lastReturned_;
}

#pragma mark Public

- (jboolean)hasMoreElements;

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;

- (void)advance;

- (JavaUtilConcurrentConcurrentHashMap_HashEntry *)nextEntry;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_HashIterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashIterator, currentTable_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashIterator, nextEntry__, JavaUtilConcurrentConcurrentHashMap_HashEntry *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_HashIterator, lastReturned_, JavaUtilConcurrentConcurrentHashMap_HashEntry *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_HashIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_HashIterator *self, JavaUtilConcurrentConcurrentHashMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_HashIterator)

@interface JavaUtilConcurrentConcurrentHashMap_KeyIterator : JavaUtilConcurrentConcurrentHashMap_HashIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_KeyIterator *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeyIterator *new_JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

@interface JavaUtilConcurrentConcurrentHashMap_ValueIterator : JavaUtilConcurrentConcurrentHashMap_HashIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_ValueIterator *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueIterator *new_JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

@interface JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry : JavaUtilAbstractMap_SimpleEntry

#pragma mark Public

- (id)setValueWithId:(id)value;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$
                                                     withId:(id)k
                                                     withId:(id)v;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry_initWithJavaUtilConcurrentConcurrentHashMap_withId_withId_(JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry *self, JavaUtilConcurrentConcurrentHashMap *outer$, id k, id v);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry *new_JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry_initWithJavaUtilConcurrentConcurrentHashMap_withId_withId_(JavaUtilConcurrentConcurrentHashMap *outer$, id k, id v) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_WriteThroughEntry)

@interface JavaUtilConcurrentConcurrentHashMap_EntryIterator : JavaUtilConcurrentConcurrentHashMap_HashIterator < JavaUtilIterator >

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntryIterator *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntryIterator *new_JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

@interface JavaUtilConcurrentConcurrentHashMap_KeySet : JavaUtilAbstractSet

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jint)size;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;


@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeySet)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeySet_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_KeySet *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySet *new_JavaUtilConcurrentConcurrentHashMap_KeySet_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeySet)

@interface JavaUtilConcurrentConcurrentHashMap_Values : JavaUtilAbstractCollection

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jint)size;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;


@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Values)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Values_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_Values *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Values *new_JavaUtilConcurrentConcurrentHashMap_Values_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Values)

@interface JavaUtilConcurrentConcurrentHashMap_EntrySet : JavaUtilAbstractSet

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jint)size;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)outer$;


@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntrySet)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntrySet_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntrySet *self, JavaUtilConcurrentConcurrentHashMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySet *new_JavaUtilConcurrentConcurrentHashMap_EntrySet_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntrySet)

#endif // _JavaUtilConcurrentConcurrentHashMap_H_
